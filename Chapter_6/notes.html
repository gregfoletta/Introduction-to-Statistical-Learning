<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Chapter 6 - Linear Model Selection and Regularization</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Chapter 6 - Linear Model Selection and Regularization</h1>

<p>This chapter, and the chapters that follow, extend the linear model framework. We discuss how the linear model can be improved by replacing the least squares with alternative fitting provedures.</p>

<p>Alternative fitting procedures can yield better:
    * Prediction Accuracy - if <em>n</em> is not much larger than <em>p</em>, there can be a lot of variability in the least squares fit, resulting in overfitting. If <em>p</em> &gt; <em>n</em> then there is no longer a unique least squares coefficient estimate. By <em>constraining</em> or <em>shrinking</em> the estimated coefficients we can reduce the variance at the cost of a negligible increase in bias.
    * Model interpretability - it is often the case that many of the variables are not associated with the response. Least squares is extremely unlikely to to yield any coefficient estimates that are exactly zero. In this chapter we see methods for <em>feature selection</em> or <em>variable selection</em>.</p>

<p>This chapter discusses three classes of methods:</p>

<ul>
<li>Subset selection - identifying a set of <em>p</em> predictors we beleive are related to the response.</li>
<li>Shrinkage - fitting a model using all <em>p</em> predictors, however the estimated coefficients are shrunken towards zero. Also known as <em>regularisation</em>.</li>
<li>Dimension reduction - involves projecting the <em>p</em> predictors into an <em>M-dimensional</em> space where M &lt; p. This is acheived by computing M different <em>linear combinations</em> or <em>projections</em>.</li>
</ul>

<h2>6.1 - Subset Selection</h2>

<p>This section discusses methods for selecting subsets of predictors.</p>

<h3>6.1.1 - Best Subset Selection</h3>

<p>To perform best subset select we fit a separate least squares regression for each posisble combination of <em>p</em> predictors. We then look at the model that is &#39;best&#39;.</p>

<p>The selection of the &#39;best&#39; model is non-trivial, and usually broken into stages:</p>

<ul>
<li>Let \(M_0\) denote the <em>null model</em>, which contains no predictors. This predicts the sample mean for each observation.</li>
<li>For \(k = 1, 2, &hellip;, p\).

<ul>
<li>Fit all \({p}\choose{k}\) models that contain exactly \(k\) predictors</li>
<li>Pick the best amongst the \({p}\choose{k}\) models and call it \(M_K\). Best is defines as the smallest RSS, or the largest \(R^2\).</li>
</ul></li>
<li>Select the single best model from \(M_0,&hellip;,M_p\) using cross-validated prediction error \(C_p\) (AIC), BIC, or adjusted \(R^2\). </li>
</ul>

<p>With \(M_0,&hellip;,M_p\), the RSS will decrease as more predictors are added, so we would always end up choosing the model with all of the variables. Hence a cross-validated error, BIC or adjusted \(R^2\) is used in order to select the model.</p>

<p>The same ideas apply to other models such as logistic. With a logistic regression we use <em>deviance</em> which plays the role of RSS for a broader class of models.</p>

<p>Best subset is simple however it suffers from comutational limitations. In general there are \(2^P\) models that involve subsets of \(p\) predictors - let&#39;s see this computationally.</p>

<pre><code class="r">library(broom)
library(tidyverse)
library(ISLR)
</code></pre>

<pre><code class="r">tibble(x = 1:30) %&gt;% 
    mutate(binom_coef = choose(max(x), x)) %&gt;% 
    summarise(sum = sum(binom_coef))
</code></pre>

<pre><code>## # A tibble: 1 x 1
##          sum
##        &lt;dbl&gt;
## 1 1073741823
</code></pre>

<pre><code class="r">2^30
</code></pre>

<pre><code>## [1] 1073741824
</code></pre>

<p>Thus &#39;Best Subset Selection&#39; becomes computationally infeasible for larger values of <em>p</em>.</p>

<h3>6.1.2 - Stepwise Selection</h3>

<p>The main issues with best subset are computational, and statistical: whem <em>p</em> is large, there&#39;s a higher chance of finding models that look good on the training data. <em>Stepwise</em> methods are attractive alternatives to best subset.</p>

<h4>Forward Stepwise Selection</h4>

<p>Forward stepwise begins with a model with no predictors, the adds predictors one at a time, until all the predictors are in the model.</p>

<ul>
<li>Let \(M_0\) denote the <em>null model</em>, which contains no predictors. This predicts the sample mean for each observation.</li>
<li>For \(k = 0, 1, &hellip;, p - 1\).

<ul>
<li>Consider all the \(p - k\) models that augment the predictors in \(M_K\) with one additional predictor.</li>
<li>Choose the best amongst these \(p - k\) models and call it \(M_{k+1}\). Here best is lowest RSS or highest \(R^2\).</li>
</ul></li>
<li>Select a single best model from among \(M_0,&hellip;,M_p\) using cross validated prediction error, \(C_p\) (AIC) or adjusted \(R^2\).</li>
</ul>

<p>This results in the fitting of \(1 + p(p + 1)/2\) models.</p>

<p>Can be used with \(n < p\), however can only generate up to \(M_{n_1}\) models.</p>

<h4>Backward Stepwise Selection</h4>

<p>Begins with all predictors, then iteratively removes the least useful predictor.</p>

<ul>
<li>Let \(M_p\) denote the <em>full model</em>, with all predictors.</li>
<li>For \(k = p,p - 1,&hellip;,0\).

<ul>
<li>Consider all \(k\) models that contain all but one of the predictors in \(M_k\).</li>
<li>Choose the best amongst these \(k\) models.</li>
</ul></li>
<li>Select a single best model among \(M_0,&hellip;,M_p\).</li>
</ul>

<p>Requires that \(n > p\).</p>

<h3>6.1.3 - Choosing the Optimal Model</h3>

<p>The training error can be a poor estimate of the test error, therefore RSS and \(R^2\) are not suitable for selecting the best model. There are two approaches:</p>

<p>1) Indirectly estimate the test error by making an <em>adjustment</em> to the training error.
2) We can directly estimate the test error using the validation set or cross-validation approach.</p>

<h4>Cp</h4>

<p>For a fitted least squares model containing \(d\) predictors, the \(C_p\) estimate of test MSE is computed using the equation:
\[ C_p = \frac{1}{n}(RSS + 2d\hat{\sigma}^2) \]</p>

<p>where \hat{\sigma}<sup>2</sup> is an estimate of the variance of the error \(\epsilon\) associated with each response measurement.</p>

<p>Essentially it adds a penalty of \(2d\hat{\sigma}^2\) to the training RSS in order to adjust for the fact the training error tends to underestimate the test error.</p>

<h4>AIC</h4>

<p>The Akaike Information Criterion is defined for a large class of models fit by maximum likelihood. In the case of a linear model with Gaussian errors, maximum likelihood and least squares are the same thing. In this case AIC is given by
\[ AIC = \frac{1}{n\hat{\sigma}^2}(RSS + 2d\hat{\sigma}^2) \]</p>

<p>hence for least squares models, \(C_p\) and AIC are proportional to each other.</p>

<h4>BIC</h4>

<p>The Bayesian Information Criterion is derived from a Bayesian point of view. For the least squares with <em>d</em> predictors the BIC is:
\[ BIC = \frac{1}{n}(RSS + log(n)d\hat{\sigma}^2) \]</p>

<h4>Adjusted R<sup>2</sup></h4>

<p>The usual \(R^2\) is defined as \(1 - RSS/TSS\), where \(TSS = \sum(y_i - \bar{y})^2\). For a least squares model with \(d\) variables, the adjusted \(R^2\) is:
\[ Adjusted R^2 = 1 - \frac{RSS / (n - d - 1)   }{TSS / (n - 1)} \]</p>

<p>The intuition is that once all of the correct variables have been included in the model, adding additional <em>noise</em> variables will lead to only a small decrease in RSS. Therefore, in theory, the model with the largest adjusted \(R^2\) will have only correct variables and no noise variables.</p>

<h4>Validation and Cross Validation</h4>

<p>As an alternative to indirect estimates, we can directly estimate the test error by using validation or cross-validation methods.</p>

<h2>6.2 - Shrinkage Methods</h2>

<p>The previous section discussed selecting a subset of the predictors. As an alternative we can fit a model with all <em>p</em> predictors using a technique that constrains or regularises the coefficient estimates, or equivalently shrinks the coefficient estimates towards zero. Shrinking the coefficient estimates can significantly reduce their variance.</p>

<p>The two best-known techniques are <em>ridge regression</em> and the <em>lasso</em>.</p>

<h3>6.2.1 - Ridge Regression</h3>

<p>Least squares estimates \(\beta_0,\ldots,\beta_p\) using values that minimise:
\[ RSS = \sum_{i=1}^n\bigg(y_i - \beta_0 - \sum_{j=1}^p\beta_jx_{ij}\bigg)^2 \]</p>

<p>Ridge regression is similar except that there is an additionaln term:
\[ RSS^R = RSS + \lambda\sum_{j=1}^p\beta_j^2 \]</p>

<p>where \(\lambda\) is a tuning parameter to be determined seperately. This \(\lambda\) is called the <em>shrinkage penalty</em>. When \(\lambda = 0\), it has no effect and the result is a least squares estimate. As \(\lambda\to\infty\), the shrinkage pentaly grows and the coefficient estimates will approach 0. We receive a different set of estimates for each \(\lambda\), so we need to choose the &#39;best&#39; \(\lambda\).</p>

<p>Standard least squares coefficients are <em>scale invariant</em> - multiplying \(X_j\) predictor by a constant \(c\) simply leads to a scaling of the least squares coefficient estimates:</p>

<pre><code class="r">auto &lt;- as.tibble(Auto)
auto %&gt;% lm(horsepower~mpg, data = .) %&gt;% tidy() %&gt;% dplyr::filter(term == &quot;mpg&quot;)
</code></pre>

<pre><code>## # A tibble: 1 x 5
##   term  estimate std.error statistic  p.value
##   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 mpg      -3.84     0.157     -24.5 7.03e-81
</code></pre>

<pre><code class="r">auto %&gt;% mutate(mpg = mpg * 1000) %&gt;% lm(horsepower~mpg, data = .) %&gt;% tidy() %&gt;% dplyr::filter(term == &quot;mpg&quot;)
</code></pre>

<pre><code>## # A tibble: 1 x 5
##   term  estimate std.error statistic  p.value
##   &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 mpg   -0.00384  0.000157     -24.5 7.03e-81
</code></pre>

<p>However with the ridge regression the coefficient estimates can change substantiall when multiplying the given predictor by a constant. Therefore it&#39;s best to standardise the predictors before applying the ridge regression with the formula:
\[ \tilde{x}_{ij} = \frac{x_{ij}}{\sqrt{\frac{1}{n}\sum_{i=1}^n(x_{ij} - \bar{x}_j)^2}} \]</p>

<p>The denominator is the estimated standard deviation of the predictor, so all the predictors will have a standard deviation of 1.</p>

<h4>Least Squares (OLS) vs Ridge Regression (RR)</h4>

<p>RR&#39;s advantage over least squares is rooted in the <em>bias-variance</em> trade-off. As \(\lambda\) increases, the flexibility of the RR fit decreases, leading to decreased variance but increased bias. At \(\lambda = 0\) the variance is high but there is no bias. As \(\lambda\) increases, the shrinkage of the RR estimates leads to a reduction in the variance at the expense of an increase in the bias.</p>

<p>In general in situations where the relationships between the predictors and the response is close to linear, the OLS will have low bias but high variance. A small change in the training data may cause a large change in the coefficient estimates. In particular when \(p\) is almost as large as \(n\) OLS will be extremely variable. RR works best in situations where the OLS estimates have a high varince.</p>

<h3>6.2.2 - The Lasso</h3>

<p>Ridge regression has one disadvantage: it will will include all \(p\) in the final model. It will shrink the coefficients to zero, but won&#39;t set them to zero. This isn&#39;t an issue with prediction, but can does pose issues for model interpretation, especially when \(p\) is large.</p>

<p>The lassoo coefficients \(\hat\beta_\lambda^L\) minimise the quantity:
\[ RSS + \lambda\sum_{j=1}^p\abs{\beta_j} \]</p>

<p>The lasso and the ridge regression have similar formulations. The lasoo uses an \(\ell_1\) penalty instead of an \(\ell_2\). The \(\ell_1\) norm of a coefficient vector \(\beta\) is given by \(\norm{\beta}_1 = \sum\abs{\beta_j}\).</p>

<p>The lasso shrinks the coefficient estimates towards zero, however the \(\ell_1\) penality forces some of the coefficients to be zero when \(\lambda\) is sufficiently large. Hence it performs variable selection.</p>

<h4>Comparing the Lasso and Ridge Regression</h4>

<p>In general the lasso performs better in a setting where a relatively small number of predictors have substantial coefficients. Ridge regression performs better when the response is a function of many predictors, all with coefficients of equal size. A procedure such as cross-validation can be used to determine which approach is better for a particular data set.</p>

<h3>6.2.3 - Selecting the Tuning Parameter</h3>

<p>Cross validation provides a simple way to tackle this problem. We choose a grid of \(\lamba\) values and compute the cross-validation error for each one. We then select the tuning parameter for which the error is smallest. The model is then re-fit using all of the available observations and the selected value of the tuning parameter.</p>

<h2>6.3 - Dimension Reduction</h2>

<p>We now explore a class of approaches that <em>transform</em> the predictors and then fit a least squares model using the transformed variables.</p>

<p>Let \(Z_1,\ldots,Z_M\) represent \(Z < p\) linear combinations of our original predictors, i.e.
\[ Z_m = \sum_{j=1}^p\phi_{jm}X_j \]
for some constants \(\phy_{1m},\ldots,\phi_{pm}\). We can then fit the linear regression model:
\[ y_i = \theta_0 + \sum_{m=1}^M\theta_mz_{im} + \epsilon_i, i = 1,\ldots,n \]</p>

<p>If the constants are chosen wisely then such dimension reduction can ofter outperform least squares regression.</p>

<p>This is termed <em>dimension reduction</em> because it reduces the problem of estimating the \(p + 1\) coefficients \(\beta_0,\ldots,\beta_p\) to the simpler problem of estimating \(M + 1\) coefficients \(\theta_0,\dots,\theta_M\), where \(M < p\).</p>

<p>Dimension reduction serves to constrain and therefore bias the coefficient estimates. However in situations where \(p\) is large relative to \(n\), selecting a value of \(M \ll p\) can significantly reduce the variance of the fitted coefficients.</p>

<p>All dimension reduction consists of obtained the transformed predictors, then a model is fit to those predictors. The choice of the transformed predictors can be achieved in different ways; we will consider <em>principal components</em> and <em>partial least squares</em>.</p>

</body>

</html>
